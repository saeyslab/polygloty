---
title: "Polyglot programming for single-cell analysis"
author:
- "Louise Deconinck"
- "Benjamin Rombaut"
- "Robrecht Cannoodt"
date: "9/12/2024"
format:
  revealjs:
    css: slides.css
    toc-depth: 1
    smaller: true
    slide-number: true
    show-slide-number: all
    embed-resources: true
    preview-links: auto
    progress: true
    history: true
    link-external-newwindow: true
jupyter: python3
exectute:
    echo: true
---

# test

{{< include ../book/in_memory/pitfalls.qmd#rpy2_mapping echo=true >}}

# Introduction

1. How do you interact with a package in another language?
2. How do you make you package useable for developers in other languages?

We will be focusing on R & Python

## Summary

**Interoperability** between languages allows analysts to take advantage of the strengths of different ecosystems

**On-disk** interoperability uses standard file formats to transfer data and is typically more reliable

**In-memory** interoperability transfers data directly between parallel sessions and is convenient for interactive analysis

While interoperability is currently possible developers continue to improve the experience

[Single-cell best practices: Interoperability](https://www.sc-best-practices.org/introduction/interoperability.html)

# How do you interact with a package in another language?

1. In-memory interoperability
2. Disk-based interoperability


# How do you make your package useable for developers in other languages?

1. Package-based interoperability
2. Best practices

## Package-based interoperability
or: the question of reimplementation.

Consider the pros:
- Discoverability
- Can your package be useful in other domains?
- Very user friendly

Consider the cons:
- Think twice: is it worth it?
- It's a lot of work
- How will you keep it up to date?
- How will you ensure parity?

## Best practices

1. Work with the standards
2. Work with matrices, arrays and dataframes
3. Provide vignettes on interoperability

# In-memory interoperability
Calling Python in an R environment and vice versa.
- No need to write out datasets.
- Best suited to calling functions

rpy2 and reticulate

## Overview

advantages & disadvantages

rpy2
1. overview
2. usage
3. pitfalls

reticulate:
1. overview
2. usage
3. pitfalls

## in-memory interoperability advantages
- no need to write & read results
- useful when you need a limited amount of functions in another language

## in-memory interoperability drawbacks
- no access to classes
- you need to extract necessary matrices & arrays for the method
- ensure that the method accepts this
- you need to be familiar with using & managing both environments
- data duplication
- you need to manage the environments

## rpy2
Accessing R from Python

Example: code block

`rpy2.rinterface`, the low-level interface
`rpy2.robjects`, the high-level interface

Example for calling R functions

Example for conversion of arrays

## rpy2
Conversion:
numpy & pandas

Example: code block

sparse matrices: anndata2ri

## rpy2

Jupyter(like) notebooks:
make use of the Magic command interface

`%load_ext rmagic`
`%R -i input -o output`

example

## rpy2

1. let your method be run with matrices and arrays as input
2. anndata2ri
?

## reticulate

# Disk-based interoperability

## General single cell file formats of interest for Python and R

{{< include ../book/disk_based/_general_file_formats.qmd >}}

## Specialized single cell file formats of interest for Python and R

{{< include ../book/disk_based/_specialized_file_formats.qmd >}}

# Workflows

# Takeaways
