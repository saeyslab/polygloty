---
title: In-memory interoperability
engine: knitr
---

One aproach to interoperability is to work on in-memory representations of one object, and convert these in memory between different programming languages. This does not require you to write out your datasets and read them in in the different programming enivronment, but it does require you to set up an environment in both languages, which can be cumbersome.
Typically, one language will act as the main host language, and you will intereact with the other language using an FFI (foreign function interface).
When evaluating R code within a Python program, we will make use of rpy2 to accomplish this. 

Rpy2 is a foreign function interface to R. It can be used in the following way:
```{python}
import rpy2
import rpy2.robjects as robjects

vector = robjects.IntVector([1,2,3])
rsum = robjects.r['sum']

rsum(vector)
```

Luckily, we're not restricted to just calling R functions and creating R objects. The real power of this in-memory interoperability lies in the conversion of Python objects to R objects to call R functions on, and then to the conversion of the results back to Python objects.

Rpy2 requires specific conversion rules for different Python objects. It is straightforward to create R vectors from corresponding Python lists:

```{python}
str_vector = robjects.StrVector(['abc', 'def', 'ghi'])
flt_vector = robjects.FloatVector([0.3, 0.8, 0.7])
int_vector = robjects.IntVector([1, 2, 3])
mtx = robjects.r.matrix(robjects.IntVector(range(10)), nrow=5)
```

However, for single cell biology, the objects that are most interesting to convert are (count) matrices, arrays and dataframes. In order to do this, you need to import the corresponding rpy2 modules and specify the conversion context.

```{python}
import numpy as np

from rpy2.robjects import numpy2ri
from rpy2.robjects import default_converter

rd_m = np.random.random((10, 7))

with (default_converter + numpy2ri.converter).context():
    mtx2 = robjects.r.matrix(rd_m, nrow = 10)
```

```{python}
import pandas as pd

from rpy2.robjects import pandas2ri

pd_df = pd.DataFrame({'int_values': [1,2,3],
                      'str_values': ['abc', 'def', 'ghi']})

with (default_converter + pandas2ri.converter).context():
    pd_df_r = robjects.DataFrame(pd_df)
```

One big limitation of rpy2 is the inability to convert sparse matrices: there is no built-in conversion module for scipy.
The `anndata2ri` package provides, apart from functionality to convert SingleCellExperiment object to an anndata object, functions to convert sparse matrices.

TODO: how to subscript sparse matrix? Is it possible?

```{r include=FALSE}
library(SingleCellExperiment)
```


```{python}
import scipy as sp

from anndata2ri import scipy2ri

sparse_matrix = sp.sparse.csc_matrix(rd_m)

with (default_converter + scipy2ri.converter).context():
    sp_r = scipy2ri.py2rpy(sparse_matrix)
```

We will showcase how to use anndata2ri to convert an anndata object to a SingleCellExperiment object and vice versa as well:
```{python}
import anndata as ad
import scanpy.datasets as scd

import anndata2ri

adata_paul = scd.paul15()

with anndata2ri.converter.context():
    sce = anndata2ri.py2rpy(adata_paul)
    ad2 = anndata2ri.rpy2py(sce)
```


Besides creating R objects and calling R functions, 

In this notebook, we will showcase how to call R code from Python.
We will make use of rpy2 and anndata2ri.

Make sure you have downloaded the data.


Read in the anndata object
```{python}
import anndata as ad

adata_path = "usecase/data/sc_counts_reannotated_with_counts.h5ad"
adata = ad.read_h5ad(adata_path)
```


We can use rpy2 to run R code within a Python process.
If you wish to convert numpy matrices, you need to use the right convertor.

This is an example of how you import rpy2, and convert a matrix for use in R functions.

```{python}
counts = adata.X # matrices are columnn major in R, and row-major in Python
counts = counts[:100, :1000] # subset for speed of example
counts_dense = counts.todense() # sparse matrices are not supported in rpy2
```


```{python}
import rpy2
import rpy2.robjects as robjects

from rpy2.robjects import numpy2ri
from rpy2.robjects import default_converter

np_cv_rules = default_converter + numpy2ri.converter

with np_cv_rules.context() as cv:
    robjects.globalenv["counts_matrix"] = counts_dense

    dim = robjects.r["dim"]
    print(dim(robjects.globalenv["counts_matrix"]))
```


# Usecase

We will perform the Compute DE step not in R, but in Python

```{python load_data}
import anndata as ad

pd_adata = ad.read_h5ad("usecase/data/pseudobulk.h5ad")
```

Select small molecule and control:

```{python select_sm_control}
sm_name = "Belinostat"
control_name = "Dimethyl Sulfoxide"
```

Create DESeq dataset:

```{python thing}
import rpy2.rinterface

from rpy2.robjects.packages import importr
base = importr('base')
print(base._libPaths())
```

```{python install}

import rpy2
import rpy2.robjects as robjects

from rpy2.robjects.packages import importr

utils = importr('utils')
# utils.install_packages('DESeq2')

## base.source("../renv/activate.R")

DESeq2 = importr("DESeq2")

```

```{python create_deseq_dataset}
import numpy as np

import rpy2
import rpy2.robjects as robjects

from rpy2.robjects import numpy2ri
from rpy2.robjects import pandas2ri

from rpy2.robjects import default_converter
from rpy2.robjects.packages import importr

DESeq2 = importr("DESeq2")

np_cv_rules = default_converter + numpy2ri.converter + pandas2ri.converter

with np_cv_rules.context() as cv:
    counts_dense = np.transpose(pd_adata.X.astype(np.int32))

    robjects.globalenv["count_data"] = counts_dense
    robjects.globalenv["obs_data"] = pd_adata.obs

```

```{python create}
from rpy2.robjects import Formula

design_formula = Formula('~ sm_name + plate_name')

dds = DESeq2.DESeqDataSetFromMatrix(countData = robjects.globalenv["count_data"],
        colData = robjects.globalenv["obs_data"],
        design = design_formula)
```


Run DESeq2:
```{python run_deseq}
dds = DESeq2.DESeq(dds)
```


Get results:
```{python get_results}
contrastv = robjects.StrVector(["sm_name", sm_name, control_name])
res = DESeq2.results(dds, contrast=contrastv)

base = importr('base')
res = base.as_data_frame(res)
```

Preview results:
```{python preview_results}
dplyr = importr('dplyr')
utils = importr('utils')

res = utils.head(dplyr.arrange(res, 'padj'), 10)
```

Write to disk:
```{python write_results}
with (robjects.default_converter + pandas2ri.converter).context():
    res_pd = robjects.conversion.get_conversion().rpy2py(res)

    res_pd.to_csv("usecase/data/de_contrasts.csv")
```

